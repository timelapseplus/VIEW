{
  "name": "linux-gpio",
  "version": "0.7.0",
  "description": "Control Raspberry Pi GPIO pins with node.js",
  "main": "linux-gpio.js",
  "keywords:": [
    "raspberry",
    "pi",
    "gpio"
  ],
  "directories": {
    "test": "test",
    "integration": "integration"
  },
  "devDependencies": {
    "mocha": "~1.18.2",
    "sinon": "~1.9.0",
    "istanbul": "~0.2.7"
  },
  "scripts": {
    "test": "mocha",
    "spec": "mocha --reporter spec",
    "coverage": "istanbul cover _mocha",
    "int": "mocha test/integration"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/JamesBarwell/rpi-gpio.js.git"
  },
  "author": {
    "name": "James Barwell",
    "email": "jb@jamesbarwell.co.uk"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "dependencies": {
    "async": "1.x",
    "debug": "2.x"
  },
  "readme": "linux-gpio\n==========\n\nControl Raspberry Pi GPIO pins with io.js / node.js\n\n[![Build Status](https://travis-ci.org/JamesBarwell/rpi-gpio.js.svg?branch=master)](https://travis-ci.org/JamesBarwell/rpi-gpio.js)\n[![NPM version](https://badge.fury.io/js/rpi-gpio.svg)](http://badge.fury.io/js/rpi-gpio)\n\n## Setup\nSee this guide on how to get [node.js running on Raspberry Pi](https://learn.adafruit.com/node-embedded-development/installing-node-dot-js).\n\nThis module can then be installed with npm:\n```\nnpm install rpi-gpio\n```\n\n### Dependency\n\nIf you are having trouble installing this module make sure you are running gcc/g++ `-v 4.8` or higher. [Here](https://github.com/fivdi/onoff/wiki/Node.js-v4-and-native-addons) is an installation guide.\n\n## Usage\nFirstly, make make sure you are running your application as root or with sudo, else the Raspberry Pi will not let you output to the GPIO.\n\nBefore you can read or write, you must use setup() to open a channel, and must specify whether it will be used for input or output. Having done this, you can then read in the state of the channel or write a value to it using read() or write().\n\nAll of the functions relating to the pin state within this module are asynchronous, so where necessary - for example in reading the value of a channel - a callback must be provided. This module inherits the standard [EventEmitter](http://nodejs.org/api/events.html), so you may use its functions to listen to events.\n\nPlease note that there are two different and confusing ways to reference a channel; either using the Raspberry Pi or the BCM/SoC naming schema (sadly, neither of which match the physical pins!). This module supports both schemas, with Raspberry Pi being the default. Please see [this page](http://elinux.org/RPi_Low-level_peripherals) for more details.\n\n## API\n\n### Methods\n\n#### setup(channel [, direction, edge], callback)\nSets up a channel for read or write. Must be done before the channel can be used.\n* channel: Reference to the pin in the current mode's schema.\n* direction: The pin direction, pass either DIR_IN for read mode or DIR_OUT for write mode. Defaults to DIR_OUT.\n* edge: Interrupt generating GPIO chip setting, pass in EDGE_NONE for no interrupts, EDGE_RISING for interrupts on rising values, EDGE_FALLING for interrupts on falling values or EDGE_BOTH for all interrupts.\nDefaults to EDGE_NONE.\n* callback: Provides Error as the first argument if an error occurred.\n\n#### read(channel, callback)\nReads the value of a channel.\n* channel: Reference to the pin in the current mode's schema.\n* callback: Provides Error as the first argument if an error occured, otherwise the pin value boolean as the second argument.\n\n#### write(channel, value [, callback])\nWrites the value of a channel.\n* channel: Reference to the pin in the current mode's schema.\n* value: Boolean value to specify whether the channel will turn on or off.\n* callback: Provides Error as the first argument if an error occured.\n\n#### setMode(mode)\nSets the channel addressing schema.\n* mode: Specify either Raspberry Pi or SoC/BCM pin schemas, by passing MODE_RPI or MODE_BCM. Defaults to MODE_RPI.\n\n#### input()\nAlias of read().\n\n#### output()\nAlias of write().\n\n#### destroy()\nTears down any previously set up channels.\n\n#### reset()\nTears down the module state - used for testing.\n\n### Events\nSee Node [EventEmitter](http://nodejs.org/api/events.html) for documentation on listening to events.\n\n#### change\nEmitted when the value of a channel changed\n* channel\n* value\n\n## Examples\n\n### Setup and read the value of a pin\n```js\nvar gpio = require('rpi-gpio');\n\ngpio.setup(7, gpio.DIR_IN, readInput);\n\nfunction readInput() {\n    gpio.read(7, function(err, value) {\n        console.log('The value is ' + value);\n    });\n}\n```\n\n### Setup and write to a pin\n```js\nvar gpio = require('rpi-gpio');\n\ngpio.setup(7, gpio.DIR_OUT, write);\n\nfunction write() {\n    gpio.write(7, true, function(err) {\n        if (err) throw err;\n        console.log('Written to pin');\n    });\n}\n```\n\n### Listen for changes on a pin\n```js\nvar gpio = require('rpi-gpio');\n\ngpio.on('change', function(channel, value) {\n\tconsole.log('Channel ' + channel + ' value is now ' + value);\n});\ngpio.setup(7, gpio.DIR_IN, gpio.EDGE_BOTH);\n```\n\n### Unexport pins opened by the module when finished\n```js\nvar gpio = require('../rpi-gpio');\n\ngpio.on('export', function(channel) {\n    console.log('Channel set: ' + channel);\n});\n\ngpio.setup(7, gpio.DIR_OUT);\ngpio.setup(15, gpio.DIR_OUT);\ngpio.setup(16, gpio.DIR_OUT, pause);\n\nfunction pause() {\n    setTimeout(closePins, 2000);\n}\n\nfunction closePins() {\n    gpio.destroy(function() {\n        console.log('All pins unexported');\n    });\n}\n```\n\n\n### Voltage cycling a pin\nThis example shows how to set up a channel for output mode. After it is set up, it executes a callback which in turn calls another, causing the voltage to alternate up and down three times.\n```js\nvar gpio = require('rpi-gpio');\n\nvar pin   = 7;\nvar delay = 2000;\nvar count = 0;\nvar max   = 3;\n\ngpio.setup(pin, gpio.DIR_OUT, on);\n\nfunction on() {\n    if (count >= max) {\n        gpio.destroy(function() {\n            console.log('Closed pins, now exit');\n        });\n        return;\n    }\n\n    setTimeout(function() {\n        gpio.write(pin, 1, off);\n        count += 1;\n    }, delay);\n}\n\nfunction off() {\n    setTimeout(function() {\n        gpio.write(pin, 0, on);\n    }, delay);\n}\n```\n\n### Using flow control modules\nDue to the asynchronous nature of this module, using an asynchronous flow control module can help to simplify development. This example uses [async.js](https://github.com/caolan/async) to turn pins on and off in series.\n```js\nvar gpio = require('rpi-gpio');\nvar async = require('async');\n\nasync.parallel([\n    function(callback) {\n        gpio.setup(7, gpio.DIR_OUT, callback)\n    },\n    function(callback) {\n        gpio.setup(15, gpio.DIR_OUT, callback)\n    },\n    function(callback) {\n        gpio.setup(16, gpio.DIR_OUT, callback)\n    },\n], function(err, results) {\n    console.log('Pins set up');\n    write();\n});\n\nfunction write() {\n    async.series([\n        function(callback) {\n            delayedWrite(7, true, callback);\n        },\n        function(callback) {\n            delayedWrite(15, true, callback);\n        },\n        function(callback) {\n            delayedWrite(16, true, callback);\n        },\n        function(callback) {\n            delayedWrite(7, false, callback);\n        },\n        function(callback) {\n            delayedWrite(15, false, callback);\n        },\n        function(callback) {\n            delayedWrite(16, false, callback);\n        },\n    ], function(err, results) {\n        console.log('Writes complete, pause then unexport pins');\n        setTimeout(function() {\n            gpio.destroy(function() {\n                console.log('Closed pins, now exit');\n            });\n        }, 500);\n    });\n};\n\nfunction delayedWrite(pin, value, callback) {\n    setTimeout(function() {\n        gpio.write(pin, value, callback);\n    }, 500);\n}\n```\n\n## Contributing\nContributions are appreciated, both in the form of bug reports and pull requests.\n\nDue to the nature of this project it can be quite time-consuming to test against real hardware, so the automated test suite is all the more important. I will not accept any pull requests that cause the build to fail, and probably will not accept any that do not have corresponding test coverage.\n\nYou can run the tests with npm:\n```\nnpm test\n```\nand create a coverage report with:\n```\nnpm run coverage\n```\nThere is also an integration test that you can run on Raspberry Pi hardware, having connected two GPIO pins across a resistor. The command to run the test will provide further instructions on how to set up the hardware:\n```\nnpm run int\n```\n\nThe tests use [mochajs](http://mochajs.org) as the test framework, and [Sinon.JS](http://sinonjs.org) to stub and mock out file system calls.\n",
  "bugs": {
    "url": "https://github.com/JamesBarwell/rpi-gpio.js/issues"
  },
  "homepage": "https://github.com/JamesBarwell/rpi-gpio.js",
  "_id": "linux-gpio@0.7.0",
  "_shasum": "92cd3eb71333695997ca41fdf1c3d07ca7dd3255",
  "_resolved": "git+https://github.com/timelapseplus/node-linux-gpio#c9b704f1b7a9f3631436ab57ebac67c287855740",
  "_from": "linux-gpio@git+https://github.com/timelapseplus/node-linux-gpio"
}
